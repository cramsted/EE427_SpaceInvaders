/*
 * render.c
 *
 *  Created on: Sep 23, 2016
 *      Author: superman
 *
 * TODO's:
 *   bunker decay
 *   score number
 *   randomize alien bullets
 *   kill aliens + update bottom row alien when one dies
 *   controls
 *   	uart input
 *   	move aliens left, right, and down
 *   	move tank left/right
 *   	create bullets
 *   	move bullets
 *   	kill aliens (just disappear)
 */
#include "render.h"
#include <stdio.h>
#include "sprites.h"
#include "xaxivdma.h"
#include "xparameters.h"
#include "xio.h"
#include "globals.h"

#define SCREEN_HEIGHT 480
#define SCREEN_WIDTH 640
//function prototypes
int findPixelValue(int x, int y, int col, int row, Sprite *sp);

void drawGround();
void drawCharacters();

#define FRAME_BUFFER_0_ADDR 0xC0000000  // Starting location in DDR where we will store the images that we display.
static XAxiVdma videoDMAController;
extern const int s_8x5[];
extern const int c_8x5[];
extern const int o_8x5[];
extern const int r_8x5[];
extern const int e_8x5[];
extern const int l_8x5[];
extern const int i_8x5[];
extern const int v_8x5[];
extern const int zero_8x5[];
extern const int one_8x5[];
extern const int two_8x5[];
extern const int three_8x5[];
extern const int four_8x5[];
extern const int five_8x5[];
extern const int six_8x5[];
extern const int seven_8x5[];
extern const int eight_8x5[];
extern const int nine_8x5[];

// Now, let's get ready to start displaying some stuff on the screen.
// The variables framePointer and framePointer1 are just pointers to the base address
// of frame 0 and frame 1.
unsigned int * framePointer0 = (unsigned int *) FRAME_BUFFER_0_ADDR;
//	unsigned int * framePointer1 = ((unsigned int *) FRAME_BUFFER_0_ADDR) + SCREEN_WIDTH
//			* SCREEN_HEIGHT;
void init() {
	// init alien positions and draw them
	// init tank position and lives and draw it
	// init bunker positions and todo: erosion and draw them
	// todo: init score (numbers)
	tank = initTank(TANK_START_X, TANK_START_Y);
	aliens = initAliens(ALIENS_START_X, ALIENS_START_Y);
	int i;
	for (i = 0; i < ALIENS_COL; i++) {
		aliens.frontRowAliens[i] = &aliens.aliens[ALIENS_ROW-1][i];
	}
	bunkers = initBunkers(BUNKER_START_X, BUNKER_START_Y);
	bullets = initBullets();
	drawGround();
	drawCharacters();
	drawTank(TANK_START_X, &tank);
	drawAliens(ALIENS_START_X, ALIENS_START_Y, &aliens);
	drawBunkers(BUNKER_START_X, BUNKER_START_Y);
	drawLives(&tank);
	//	render(); //needed only for changing the index of the frame buffer
//	int j;
	//	int endx = SCREEN_WIDTH - ((aliens.aliens[0][0].sp.width + 8) * 10);
	//	int endy = SCREEN_HEIGHT - ALIENS_START_Y - ((aliens.aliens[0][0].sp.height
	//			+ 16) * 5);
	//	for (j = ALIENS_START_Y; j < endy; j += 10) {
	//		for (i = ALIENS_START_X; i < endx; i++) {
	//			drawAliens(i, j);
	//			volatile unsigned int j = 0;
	//			while (j < 50000) {
	//				j++;
	//			}
	//		}
	//	}

	for (i = 0; i < ALIENS_COL; i++) {
		Alien *a = aliens.frontRowAliens[i];
		xil_printf("front row alien (x,y) = (%d,%d)\n\r", a->p.x, a->p.y);
	}

	tankPew(&tank, &bullets);
	alienPew(&aliens, &bullets);
	alienPew(&aliens, &bullets);
	alienPew(&aliens, &bullets);
	alienPew(&aliens, &bullets);
	for (i = 0; i < 20; i++) {
		updateBullets(&bullets);
		volatile int j = 0;
		while (j < 4000000) {
			j++;
		}
	}
}

void drawGround() {
	memset(framePointer0, 0, SCREEN_WIDTH * SCREEN_HEIGHT * 4); //clears screen
	int col;
	for (col = 0; col < SCREEN_WIDTH; col++) {
		framePointer0[GROUND_START_Y * SCREEN_WIDTH + col] = GREEN;
		framePointer0[(GROUND_START_Y + 1) * SCREEN_WIDTH + col] = GREEN;
	}
}

void drawCharacters() {
	const int *scoreArray[] = { s_8x5, c_8x5, o_8x5, r_8x5, e_8x5 };
	int i;
	for (i = 0; i < MAX_CHARACTER_LETTERS; i++) {
		Character s = initChar(
				(SCORE_START_X + (CHARACTER_WIDTH + CHARACTER_PADDING) * i),
				TEXT_START_Y, scoreArray[i]);
		edit_frameBuffer(&s.sp, &s.p);
	}

	const int *livesArray[] = { l_8x5, i_8x5, v_8x5, e_8x5, s_8x5 };
	for (i = 0; i < MAX_CHARACTER_LETTERS; i++) {
		Character s = initChar(
				(LIVES_START_X + (CHARACTER_WIDTH + CHARACTER_PADDING) * i),
				TEXT_START_Y, livesArray[i]);
		edit_frameBuffer(&s.sp, &s.p);
	}
}






void render() {
	if (XST_FAILURE == XAxiVdma_StartParking(&videoDMAController, 0, //the 0 is the frame index
			XAXIVDMA_READ)) {
		xil_printf("vdma parking failed\n\r");
	}
}

void edit_frameBuffer(Sprite *sp, Position *p) {
	int maxRow = (p->y + sp->height);
	int maxCol = (p->x + sp->width);
	int row, col;
	for (row = p->y; row < maxRow; row++) {
		for (col = p->x; col < maxCol; col++) {
			if (findPixelValue(p->x, p->y, col, row, sp)) {
				framePointer0[row * SCREEN_WIDTH + col] = sp->Color.color;
			} else {
				framePointer0[row * SCREEN_WIDTH + col] = 0x00000000;
			}
		}
	}

}

int findPixelValue(int x, int y, int col, int row, Sprite *sp) {
	int xval = (col - x) >> 1;
	int yval = (row - y) >> 1;
	int mask = 1 << ((sp->width >> 1) - 1);
	return (sp->sprite[yval] << xval) & mask;
}

void init_videoDMAController() {
	int Status; // Keep track of success/failure of system function calls.
	XAxiVdma videoDMAController;
	// There are 3 steps to initializing the vdma driver and IP.
	// Step 1: lookup the memory structure that is used to access the vdma driver.
	XAxiVdma_Config * VideoDMAConfig = XAxiVdma_LookupConfig(
			XPAR_AXI_VDMA_0_DEVICE_ID);
	// Step 2: Initialize the memory structure and the hardware.
	if (XST_FAILURE == XAxiVdma_CfgInitialize(&videoDMAController,
			VideoDMAConfig, XPAR_AXI_VDMA_0_BASEADDR)) {
		xil_printf("VideoDMA Did not initialize.\r\n");
	}
	// Step 3: (optional) set the frame store number.
	if (XST_FAILURE == XAxiVdma_SetFrmStore(&videoDMAController, 2,
			XAXIVDMA_READ)) {
		xil_printf("Set Frame Store Failed.");
	}
	// Initialization is complete at this point.

	// Setup the frame counter. We want two read frames. We don't need any write frames but the
	// function generates an error if you set the write frame count to 0. We set it to 2
	// but ignore it because we don't need a write channel at all.
	XAxiVdma_FrameCounter myFrameConfig;
	myFrameConfig.ReadFrameCount = 2;
	myFrameConfig.ReadDelayTimerCount = 10;
	myFrameConfig.WriteFrameCount = 2;
	myFrameConfig.WriteDelayTimerCount = 10;
	Status = XAxiVdma_SetFrameCounter(&videoDMAController, &myFrameConfig);
	if (Status != XST_SUCCESS) {
		xil_printf("Set frame counter failed %d\r\n", Status);
		if (Status == XST_VDMA_MISMATCH_ERROR)
			xil_printf("DMA Mismatch Error\r\n");
	}
	// Now we tell the driver about the geometry of our frame buffer and a few other things.
	// Our image is SCREEN_HEIGHT x SCREEN_WIDTH.
	XAxiVdma_DmaSetup myFrameBuffer;
	myFrameBuffer.VertSizeInput = SCREEN_HEIGHT; // SCREEN_HEIGHT vertical pixels.
	myFrameBuffer.HoriSizeInput = SCREEN_WIDTH * 4; // SCREEN_WIDTH horizontal (32-bit pixels).
	myFrameBuffer.Stride = SCREEN_WIDTH * 4; // Dont' worry about the rest of the values.
	myFrameBuffer.FrameDelay = 0;
	myFrameBuffer.EnableCircularBuf = 1;
	myFrameBuffer.EnableSync = 0;
	myFrameBuffer.PointNum = 0;
	myFrameBuffer.EnableFrameCounter = 0;
	myFrameBuffer.FixedFrameStoreAddr = 0;
	if (XST_FAILURE == XAxiVdma_DmaConfig(&videoDMAController, XAXIVDMA_READ,
			&myFrameBuffer)) {
		xil_printf("DMA Config Failed\r\n");
	}
	// We need to give the frame buffer pointers to the memory that it will use. This memory
	// is where you will write your video data. The vdma IP/driver then streams it to the HDMI
	// IP.
	myFrameBuffer.FrameStoreStartAddr[0] = FRAME_BUFFER_0_ADDR;
	//	myFrameBuffer.FrameStoreStartAddr[1] = FRAME_BUFFER_0_ADDR + 4 * SCREEN_WIDTH * SCREEN_HEIGHT;

	if (XST_FAILURE == XAxiVdma_DmaSetBufferAddr(&videoDMAController,
			XAXIVDMA_READ, myFrameBuffer.FrameStoreStartAddr)) {
		xil_printf("DMA Set Address Failed Failed\r\n");
	}
	// Print a sanity message if you get this far.
	xil_printf("Woohoo! I made it through initialization.\n\r");

	// Start the DMA for the read channel only.
	if (XST_FAILURE == XAxiVdma_DmaStart(&videoDMAController, XAXIVDMA_READ)) {
		xil_printf("DMA START FAILED\r\n");
	}
	// We have two frames, let's park on frame 0. Use frameIndex to index them.
	// Note that you have to start the DMA process before parking on a frame.
	if (XST_FAILURE == XAxiVdma_StartParking(&videoDMAController, 0, //the 0 is the frame index
			XAXIVDMA_READ)) {
		xil_printf("vdma parking failed\n\r");
	}
	// This tells the HDMI controller the resolution of your display (there must be a better way to do this).
	XIo_Out32(XPAR_AXI_HDMI_0_BASEADDR, SCREEN_WIDTH*SCREEN_HEIGHT);
}
