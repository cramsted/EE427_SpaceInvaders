/*
 * aliens.c
 *
 *  Created on: Sep 27, 2016
 *      Author: superman
 */
#include "aliens.h"
#include "bunkers.h"
#include "render.h"		//for access to the frame buffer
#include "text.h"		//for access to the function updateScore()
#include <stdio.h>		//xil_printf for debugging purposes
#include "timer.h"

//values that determine the dimensions of the sprites on the screen
#define ALIEN_HEIGHT (8*2)		//alien sprite height
#define ALIEN_WIDTH (12*2)		//alien sprite width
#define XALIEN_PADDING (8)		//padding between aliens in the x direction
#define YALIEN_PADDING (16)		//padding between aliens in the y direction
#define RIGHT_PADDING 12			//padding for the max value the aliens can be drawn in the x direciton
#define ALIENS_BLOCK_WIDTH ((ALIEN_WIDTH + XALIEN_PADDING) * ALIENS_COL)
#define MAX_X (SCREEN_WIDTH - RIGHT_PADDING - ALIEN_WIDTH) //fix me!
#define MIN_X RIGHT_PADDING
#define MAX_Y 400
#define LEFT_SCREEN_X (SCREEN_WIDTH >> 2)
//point values for different alien types
#define TOP_ALIEN_POINTS 40
#define MIDDLE_ALIEN_POINTS 20
#define BOTTOM_ALIEN_POINTS 10

#define MAX_EXPLOSION_SPRITES 3

//all the sprite structures defined in sprite_bit_maps.c
extern const int saucer_16x7[]; //saucer sprite, not used in this lab
extern const int alien_explosion_12x10[]; //alien explosion spirte
extern const int alien_top_in_12x8[]; //top row alien sprite with legs in
extern const int alien_top_out_12x8[]; //top row alien sprite with legs out
extern const int alien_middle_in_12x8[]; //middle row alien sprite with legs in
extern const int alien_middle_out_12x8[]; //middle row alien sprite with legs out
extern const int alien_bottom_in_12x8[]; //bottom row alien sprite with legs in
extern const int alien_bottom_out_12x8[]; //bottom row alien sprite with legs out
extern const int alien_explosion_12x8[]; //exploding alien sprite

//struct of pointers to all alien sprites for easy reference by index value
const int* alien_sprites[] = { alien_top_in_12x8, alien_top_out_12x8,
		alien_middle_in_12x8, alien_middle_out_12x8, alien_bottom_in_12x8,
		alien_bottom_out_12x8 };

Aliens aliens;
static Alien *explodedAliens[MAX_EXPLOSION_SPRITES] = { NULL, NULL, NULL };

// Function prototypes
void eraseAlien(Alien *alien);

//initialize an alien struct
//param x sets starting x position
//param y sets starting y position
//param type sets the type and guise of the alien
//param row sets the row the alien will be in
static void initAlien(int x, int y, int row, int col, alien_type_e type) {
	Alien *a = &aliens.aliens[row][col];
	a->status = alive; //set life status
	a->p = initPosition(x, y); //set initial x,y position
	a->type = type; //set alien sprite type

	//initializes the sprite to an alien
	a->sp = initSprite(ALIEN_HEIGHT, ALIEN_WIDTH, WHITE, alien_sprites[type]);
}

//function to initialize an alien struct
// param x sets starting x position
//param y sets starting y position
void initAliens(int x, int y) {
	aliens.numActiveBullets = 0; //inits the number of active alien bullets to 0
	aliens.direction = right; //starts alien block moving right on the screen
	int row, col;
	const uint32_t alien_width = ALIEN_WIDTH + XALIEN_PADDING; //width of of sprite plus padding
	const uint32_t alien_height = ALIEN_HEIGHT + YALIEN_PADDING; //height of sprite plus padding

	//populates the aliens[][] struct with alien structs
	for (row = 0; row < ALIENS_ROW; row++) {
		for (col = 0; col < ALIENS_COL; col++) {
			alien_type_e type;
			if (row == 0) { //puts top aliens in top row
				type = top_alien_in;
			} else if (row >= 1 && row < 3) { //puts middle aliens in middle row
				type = middle_alien_in;
			} else { //puts bottom aliens in bottom row
				type = bottom_alien_in;
			}

			//initializes the alien with the correct x,y coordinate and type
			initAlien(ALIENS_START_X + (col * alien_width),
					ALIENS_START_Y + (row * alien_height), row, col, type);
		}
	}

	// Create a list of pointers to aliens that are on the front row
	// so it's easy to keep track of which aliens can fire a bullet.
	int i;
	for (i = 0; i < ALIENS_COL; i++) { //sets which aliens are on the front row of the alien block
		aliens.frontRowAliens[i] = &aliens.aliens[ALIENS_ROW - 1][i];
	}
}

void addExplodedAlienSprite(Alien *alien) {
	// Add the alien to the list of explosion sprites so they can be erased
	uint8_t i;
	for (i = 0; i < MAX_EXPLOSION_SPRITES; i++) {
		if (explodedAliens[i] == NULL) {
			explodedAliens[i] = alien;
		}
	}
}

//erases of an exploded alien sprite if it hasn't already been erased
void eraseAlienExplosionSprite() {
	uint8_t i;
	for (i = 0; i < MAX_EXPLOSION_SPRITES; i++) {
		if (explodedAliens[i] != NULL) {
			eraseAlien(explodedAliens[i]);
			explodedAliens[i] = NULL;
		}
	}

}

//erases the passed in alien by changing it's sprite color to match the background
void eraseAlien(Alien *alien) {
	alien->sp.Color.color = BLACK;
	editFrameBuffer(&alien->sp, &alien->p); //makes change in the frame buffer
}

//draws an exploding alien sprite
void explodeAlien(Alien *alien) {
	alien->sp.sprite = alien_explosion_12x8;
	editFrameBuffer(&alien->sp, &alien->p);
	addExplodedAlienSprite(alien);
}

//sets the status var of the alien at the passed in row and col as dead
void killAlien(Alien *alien, int row, int col) {
	alien->status = dead;
	explodeAlien(alien); //removes alien from the screen
	setAlienExplosionCounter();

	// adjust frontRowAliens, which keeps track of which aliens can fire a bullet
	if (row != 0) {
		//makes sure that the alien next in line is alive
		int i = row - 1;
		while ((aliens.aliens[i][col].status == dead) && (i > 0)) {
			i--;
		}
		aliens.frontRowAliens[col] = &aliens.aliens[i][col];
	}

	// update the score
	switch (alien->type) {
	case top_alien_in:
	case top_alien_out:
		updateScore(TOP_ALIEN_POINTS);
		break;
	case middle_alien_in:
	case middle_alien_out:
		updateScore(MIDDLE_ALIEN_POINTS);
		break;
	case bottom_alien_in:
	case bottom_alien_out:
		updateScore(BOTTOM_ALIEN_POINTS);
		break;
	default:
		break;
	}
}

void drawAlien(int xUpdate, int yUpdate, Alien *alien) {
	if (alien->status == alive) {
		// erase the alien and update its position
		eraseAlien(alien);
		alien->p.x += xUpdate;
		alien->p.y += yUpdate;

		// change the type from out to in or vice versa
		(alien->type & 1) ? alien->type-- : alien->type++;
		alien->sp.sprite = alien_sprites[alien->type];

		// redraw the alien
		alien->sp.Color.color = WHITE;
		editFrameBuffer(&alien->sp, &alien->p);
	}
}

//draws the block of aliens at the specified x,y coordinate on the screen
void drawAliens(int xUpdate, int yUpdate) {
	int row, col;
	if (aliens.direction == left) { // moving left
		for (row = 0; row < ALIENS_ROW; row++) {
			for (col = 0; col < ALIENS_COL; col++) {
				Alien *temp = &aliens.aliens[row][col];
				drawAlien(xUpdate, yUpdate, temp);
			}
		}
	} else { // moving right or down
		for (row = ALIENS_ROW - 1; row >= 0; row--) {
			for (col = ALIENS_COL - 1; col >= 0; col--) {
				Alien *temp = &aliens.aliens[row][col];
				drawAlien(xUpdate, yUpdate, temp);
			}
		}
	}
}

// We want to find the leftmost column with living aliens
// Used for bounds checking when the aliens are moving left
Position aliensLeftBlockPosition() {
	int row, col;
	for (col = 0; col < ALIENS_COL; col++) {
		for (row = 0; row < ALIENS_ROW; row++) {
			if (aliens.aliens[row][col].status == alive)
				return aliens.aliens[row][col].p;
		}
	}
	return initPosition(ALIENS_START_X, ALIENS_START_Y);
}

// Same as the aliensLeftBlockPosition, but used for bounds checking on the right
Position aliensRightBlockPosition() {
	int row, col;
	for (col = ALIENS_COL - 1; col >= 0; col--) {
		for (row = ALIENS_ROW - 1; row >= 0; row--) {
			if (aliens.aliens[row][col].status == alive)
				return aliens.aliens[row][col].p;
		}
	}
	return initPosition(ALIENS_START_X, ALIENS_START_Y);
}

//moves the alien block a predetermined distance and direction
void updateAliens() {
	Position p;
	switch (aliens.direction) {
	case left:
		drawAliens(left, 0);
		p = aliensLeftBlockPosition();
		if (p.x < MIN_X) {
			aliens.direction = down;
		}
		break;
	case right:
		drawAliens(right, 0);
		p = aliensRightBlockPosition();
		if (p.x > MAX_X) {
			aliens.direction = down;
		}
		break;
	case down:
		drawAliens(0, down);
		p = aliensLeftBlockPosition();
		if (p.y < MAX_Y) {
			if (p.x < LEFT_SCREEN_X) {
				aliens.direction = right;
			} else {
				aliens.direction = left;
			}
		}
		break;
	default:
		break;
	}
}
static int alienCollidesWithBunker(int alienX, int alienY, Bunker *bunker) {
	int i;
	for (i = 0; i < MAX_BUNKERS; i++) {
		Position *spritePos = &bunker->p;
		Sprite *sprite = &bunker->sp;
		int spriteX = spritePos->x;
		int spriteY = spritePos->y;
		int spriteXMax = spriteX + sprite->width;
		int spriteYMax = spriteY + sprite->height;
		int alienXMax = alienX + ALIEN_WIDTH;
		int alienYMax = alienY + ALIEN_HEIGHT;

	}
}

void bunkerCollisionCheck(int alienX, int alienY) {
	int i;
	for (i = 0; i < MAX_BUNKERS; i++) {
		static int alienCollidesWithBunker(int alienX, int alienY, &bunkers.bunkers[i]);

	}
}
